<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8">
<title>LS Paint 0.1</title>
<style>
:root{--bg:#e8e8e8;--bar:#f0f0f0;--bar2:#f5f5f5;--border:#ccc;--border2:#d0d0d0;--surface:#fff;--text:#333;--text2:#555;--text3:#888;--hover:#e0e0e0;--active:#cde4f7;--active-border:#7eb4ea;--active-bg:#b8d6f0;--menu-hover:#e8f0fe;--input-bg:#fff;--input-border:#bbb;--input-focus:#4a90d9;--workspace:#c0c0c0;--canvas-shadow:none;--btn-bg:#fff;--btn-bg2:#f0f0f0;--accent:#4a90d9;--accent2:#3a7ac0;--dialog-bg:#fff;--sep:#ccc;--handle:#4a90d9;--handle-border:#2a6ab5}
body.dark{--bg:#1e1e1e;--bar:#2a2a2a;--bar2:#252525;--border:#444;--border2:#3a3a3a;--surface:#333;--text:#ddd;--text2:#aaa;--text3:#777;--hover:#3a3a3a;--active:#1a3a5c;--active-border:#4a7aaa;--active-bg:#2a4a6a;--menu-hover:#2a3a4a;--input-bg:#2a2a2a;--input-border:#555;--input-focus:#5a9ada;--workspace:#3a3a3a;--canvas-shadow:0 0 20px rgba(0,0,0,.4);--btn-bg:#333;--btn-bg2:#383838;--accent:#5a9ada;--accent2:#4a8aca;--dialog-bg:#2e2e2e;--sep:#444;--handle:#5a9ada;--handle-border:#4a7aaa}
*{margin:0;padding:0;box-sizing:border-box;user-select:none}
body{font-family:Segoe UI,Tahoma,sans-serif;font-size:13px;background:var(--bg);display:flex;flex-direction:column;height:100vh;overflow:hidden;color:var(--text)}

/* === MENU BAR === */
#menubar{display:flex;background:var(--bar2);border-bottom:1px solid var(--border);padding:2px 4px;gap:2px}
.menu-item{position:relative;padding:3px 10px;border-radius:3px;cursor:pointer;color:var(--text)}
.menu-item:hover,.menu-item.open{background:var(--hover)}
.menu-dropdown{display:none;position:absolute;left:0;top:100%;background:var(--surface);border:1px solid var(--border);border-radius:4px;box-shadow:2px 4px 12px rgba(0,0,0,.15);min-width:200px;z-index:1000;padding:4px 0;color:var(--text)}
.menu-item.open .menu-dropdown{display:block}
.menu-dropdown div{padding:6px 30px 6px 12px;cursor:pointer;white-space:nowrap;display:flex;justify-content:space-between}
.menu-dropdown div:hover{background:var(--menu-hover)}
.menu-dropdown div.sep{border-top:1px solid var(--border);margin:4px 0;padding:0;pointer-events:none}
.menu-dropdown .shortcut{color:var(--text3);margin-left:30px;font-size:12px}

/* === TOOLBAR === */
#toolbar{display:flex;align-items:center;background:var(--bar);border-bottom:1px solid var(--border);padding:4px 8px;gap:6px;flex-wrap:wrap}
.tool-group{display:flex;align-items:center;gap:2px;padding:2px 6px;border-right:1px solid var(--border2)}
.tool-group:last-child{border-right:none}
.tool-btn{min-width:36px;height:32px;border:1px solid transparent;border-radius:3px;background:none;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:600;color:var(--text);flex-direction:column;gap:1px;position:relative;padding:0 3px}
.tool-btn:hover{background:var(--hover);border-color:var(--border)}
.tool-btn.active{background:var(--active);border-color:var(--active-border)}
.tool-btn svg{width:18px;height:18px}
.tool-btn span{font-size:9px;line-height:1}

.tool-label{font-size:12px;color:var(--text2);margin:0 4px;line-height:32px}
#brushSize{width:80px;vertical-align:middle}
#brushSizeVal{width:42px;font-size:12px;color:var(--text);border:1px solid var(--input-border);border-radius:3px;padding:2px 4px;text-align:center;font-family:inherit;background:var(--input-bg);-moz-appearance:textfield}
#brushSizeVal::-webkit-inner-spin-button,#brushSizeVal::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}
#brushSizeVal:focus{border-color:var(--input-focus);outline:none}
.shape-style-group{display:flex;align-items:center;gap:2px}
.shape-btn{width:28px;height:26px;border:1px solid transparent;border-radius:3px;background:none;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--text)}
.shape-btn:hover{background:var(--hover);border-color:var(--border)}
.shape-btn.active{background:var(--active);border-color:var(--active-border)}
.shape-btn svg{width:18px;height:18px}

/* tool dropdown (select modes) */
.tool-btn-drop{position:relative;display:flex}
.tool-btn-drop .tool-btn{border-radius:3px 0 0 3px}
.drop-arrow{width:14px;height:32px;border:1px solid transparent;border-left:none;border-radius:0 3px 3px 0;background:none;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--text2);font-size:10px;padding:0}
.drop-arrow:hover{background:var(--hover);border-color:var(--border)}
.tool-btn-drop .tool-btn.active~.drop-arrow{background:var(--active-bg);border-color:var(--active-border)}
.drop-menu{display:none;position:absolute;top:100%;left:0;background:var(--surface);border:1px solid var(--border);border-radius:4px;box-shadow:2px 4px 12px rgba(0,0,0,.15);z-index:1000;padding:4px 0;min-width:170px;color:var(--text)}
.drop-menu.open{display:block}
.drop-menu div{padding:6px 12px;cursor:pointer;white-space:nowrap;font-size:12px;display:flex;align-items:center;gap:8px}
.drop-menu div:hover{background:var(--menu-hover)}
.drop-menu div.dm-active{font-weight:600;background:var(--menu-hover)}
.drop-menu div svg{width:16px;height:16px;flex-shrink:0}

/* size +/- buttons */
.size-btn{width:22px;height:22px;border:1px solid var(--input-border);border-radius:3px;background:var(--btn-bg);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:16px;font-weight:bold;color:var(--text2);line-height:1;padding:0 0 2px}
.size-btn:hover{background:var(--hover);border-color:var(--border)}
.size-btn:active{background:var(--hover)}

/* === WORKSPACE === */
#workspace{flex:1;overflow:auto;background:var(--workspace);position:relative;display:flex;align-items:flex-start;justify-content:flex-start}
#canvas-area{position:relative;margin:20px;display:inline-block;flex-shrink:0}
#canvas{image-rendering:-moz-crisp-edges;image-rendering:-webkit-crisp-edges;image-rendering:pixelated;image-rendering:crisp-edges;background:#fff;cursor:crosshair;display:block;box-shadow:var(--canvas-shadow)}
#overlay{position:absolute;top:0;left:0;pointer-events:none;image-rendering:-moz-crisp-edges;image-rendering:-webkit-crisp-edges;image-rendering:pixelated;image-rendering:crisp-edges}
.resize-handle{position:absolute;width:8px;height:8px;background:var(--handle);border:1px solid var(--handle-border);z-index:10}
#resize-se{bottom:-10px;right:-10px;cursor:nwse-resize}
#resize-s{bottom:-10px;left:50%;transform:translateX(-50%);cursor:ns-resize}
#resize-e{right:-10px;top:50%;transform:translateY(-50%);cursor:ew-resize}

/* text editing overlay */
#text-wrapper{position:absolute;display:none;z-index:20}
#text-bar{display:flex;align-items:center;gap:2px;background:var(--accent);padding:1px 3px;cursor:move;border-radius:3px 3px 0 0;height:18px}
#text-commit{width:18px;height:14px;border:none;background:rgba(255,255,255,.3);border-radius:2px;cursor:pointer;color:#fff;font-size:12px;display:flex;align-items:center;justify-content:center;padding:0;line-height:1;margin-left:auto}
#text-commit:hover{background:rgba(255,255,255,.5)}
#text-content{border:1px dashed var(--accent);border-top:none;background:transparent;outline:none;font-family:sans-serif;overflow:hidden;min-width:40px;min-height:20px;padding:2px 4px;white-space:pre-wrap;word-wrap:break-word;overflow-wrap:break-word;resize:both}
.fmt-cb{font-size:12px;cursor:pointer;display:flex;align-items:center;gap:3px;color:var(--text2);margin-left:6px;white-space:nowrap}
.fmt-cb input{margin:0}
#fontFamily{font-size:12px;padding:2px 4px;border:1px solid var(--input-border);border-radius:3px;background:var(--input-bg);color:var(--text);max-width:130px;font-family:inherit;color-scheme:light dark}
#fontFamily option{background:var(--input-bg);color:var(--text)}
#fontFamily:focus{border-color:var(--input-focus);outline:none}
#fontSizeInput{width:42px;font-size:12px;color:var(--text);border:1px solid var(--input-border);border-radius:3px;padding:2px 4px;text-align:center;font-family:inherit;background:var(--input-bg);-moz-appearance:textfield}
#fontSizeInput::-webkit-inner-spin-button,#fontSizeInput::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}
#fontSizeInput:focus{border-color:var(--input-focus);outline:none}

/* === BOTTOM BAR === */
#bottombar{display:flex;align-items:center;background:var(--bar);border-top:1px solid var(--border);padding:4px 8px;gap:8px}
#color-display{display:flex;align-items:center;gap:4px;padding:0 8px}
#fg-bg-box{position:relative;width:36px;height:36px}
#bg-color-box{position:absolute;right:0;bottom:0;width:24px;height:24px;border:2px solid var(--bar);outline:1px solid var(--text3);cursor:pointer}
#fg-color-box{position:absolute;left:0;top:0;width:24px;height:24px;border:2px solid var(--bar);outline:1px solid var(--text3);cursor:pointer;z-index:1}
#swap-colors{font-size:14px;cursor:pointer;margin-left:4px;background:none;border:none;color:var(--text2);padding:2px}
#swap-colors:hover{color:var(--text)}

#palette{display:flex;gap:1px;flex-wrap:wrap;max-width:420px}
.color-cell{width:20px;height:20px;border:1px solid var(--text3);cursor:pointer;border-radius:1px}
.color-cell:hover{border-color:var(--text);transform:scale(1.15);z-index:1}
#custom-color-btn{width:20px;height:20px;border:1px solid var(--text3);cursor:pointer;border-radius:1px;background:linear-gradient(135deg,red,yellow,green,cyan,blue,magenta);font-size:10px;display:flex;align-items:center;justify-content:center}

.bar-sep{width:1px;height:30px;background:var(--sep);margin:0 6px}
#statusbar{display:flex;align-items:center;gap:16px;margin-left:auto;font-size:12px;color:var(--text2)}
#statusbar span{white-space:nowrap}
#zoom-controls{display:flex;align-items:center;gap:2px}
#zoom-controls .zbtn{width:20px;height:20px;border:1px solid var(--input-border);border-radius:3px;background:var(--btn-bg);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:14px;font-weight:bold;color:var(--text2);line-height:1;padding:0 0 2px}
#zoom-controls .zbtn:hover{background:var(--hover);border-color:var(--border)}
#zoom-controls .zbtn:active{background:var(--hover)}
#stat-zoom{min-width:40px;text-align:center}
#size-edit{display:flex;align-items:center;gap:3px}
.dim-group{display:flex;align-items:center;gap:0}
.dim-group input{width:52px;font-size:12px;border:1px solid var(--input-border);border-radius:0;padding:2px 4px;text-align:center;font-family:inherit;color:var(--text);background:var(--input-bg);-moz-appearance:textfield}
.dim-group input::-webkit-inner-spin-button,.dim-group input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}
.dim-group input:focus{border-color:var(--input-focus);outline:none;z-index:1;position:relative}
.dim-btn{width:18px;height:24px;border:1px solid var(--input-border);background:var(--btn-bg2);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:14px;font-weight:bold;color:var(--text2);padding:0 0 2px;line-height:1}
.dim-btn:hover{background:var(--hover);border-color:var(--border)}
.dim-btn:active{background:var(--hover)}
.dim-btn.left{border-radius:3px 0 0 3px;border-right:none}
.dim-btn.right{border-radius:0 3px 3px 0;border-left:none}
#size-edit .size-x{font-size:11px;color:var(--text3);margin:0 2px}

/* confirm dialog overlay */
#confirm-dialog{display:none;position:fixed;inset:0;z-index:2000;background:rgba(0,0,0,.3);align-items:center;justify-content:center}
#confirm-dialog.open{display:flex}
#confirm-dialog .dialog-box{background:var(--dialog-bg);border-radius:8px;box-shadow:0 8px 32px rgba(0,0,0,.25);padding:20px 24px;min-width:320px;max-width:420px}
#confirm-dialog .dialog-box p{margin:0 0 16px;font-size:14px;color:var(--text);line-height:1.5}
#confirm-dialog .dialog-btns{display:flex;justify-content:flex-end;gap:8px}
#confirm-dialog .dialog-btns button{padding:6px 18px;border-radius:4px;border:1px solid var(--border);background:var(--btn-bg2);cursor:pointer;font-size:13px;color:var(--text)}
#confirm-dialog .dialog-btns button:hover{background:var(--hover)}
#confirm-dialog .dialog-btns button.primary{background:var(--accent);color:#fff;border-color:var(--accent2)}
#confirm-dialog .dialog-btns button.primary:hover{background:var(--accent2)}

/* help panel */
#help-btn{width:22px;height:22px;border-radius:50%;border:1px solid var(--input-border);background:var(--btn-bg);cursor:pointer;font-size:13px;font-weight:bold;color:var(--accent);display:flex;align-items:center;justify-content:center;padding:0 0 1px;flex-shrink:0}
#help-btn:hover{background:var(--menu-hover);border-color:var(--accent)}
#help-overlay{display:none;position:fixed;inset:0;z-index:2000;background:rgba(0,0,0,.35);align-items:center;justify-content:center}
#help-overlay.open{display:flex}
#help-panel{background:var(--dialog-bg);border-radius:10px;box-shadow:0 8px 40px rgba(0,0,0,.25);padding:24px 28px;max-width:560px;width:90vw;max-height:80vh;overflow-y:auto;position:relative}
#help-panel h2{margin:0 0 16px;font-size:18px;color:var(--text)}
#help-panel .hgroup{margin-bottom:14px}
#help-panel .hgroup h3{font-size:13px;color:var(--accent);text-transform:uppercase;letter-spacing:.5px;margin:0 0 6px;padding-bottom:4px;border-bottom:1px solid var(--border)}
#help-panel .hrow{display:flex;gap:10px;padding:3px 0;font-size:13px;color:var(--text)}
#help-panel .hkey{min-width:150px;font-weight:600;color:var(--text2);flex-shrink:0;font-family:monospace;font-size:12px}
#help-panel .hdesc{color:var(--text2)}
#help-close{position:absolute;top:12px;right:16px;background:none;border:none;font-size:22px;cursor:pointer;color:var(--text3);padding:4px}
#help-close:hover{color:var(--text)}

/* hidden helpers */
input[type=file]{display:none}
input[type=color]{position:absolute;visibility:hidden;width:0;height:0}

/* dropzone overlay */
#dropzone{display:none;position:absolute;inset:0;background:rgba(74,144,217,.2);border:3px dashed var(--accent);z-index:100;pointer-events:none;align-items:center;justify-content:center;font-size:24px;color:var(--accent2)}

/* dark mode toggle */
.dm-switch{display:flex;align-items:center;gap:5px;margin-left:auto;cursor:pointer;font-size:12px;color:var(--text2)}
.dm-switch input{display:none}
.dm-track{width:32px;height:18px;background:var(--border);border-radius:9px;position:relative;transition:background .2s}
.dm-switch input:checked~.dm-track{background:var(--accent)}
.dm-knob{width:14px;height:14px;background:var(--surface);border-radius:50%;position:absolute;top:2px;left:2px;transition:left .2s;box-shadow:0 1px 3px rgba(0,0,0,.2)}
.dm-switch input:checked~.dm-track .dm-knob{left:16px}
</style>
</head>
<body>

<!-- MENU BAR -->
<div id="menubar">
  <div class="menu-item" data-menu="file">File
    <div class="menu-dropdown">
      <div data-action="new">New <span class="shortcut">Ctrl+N</span></div>
      <div data-action="open">Open... <span class="shortcut">Ctrl+O</span></div>
      <div class="sep"></div>
      <div data-action="save-png">Save as PNG <span class="shortcut">Ctrl+S</span></div>
      <div data-action="save-jpg">Save as JPEG</div>
      <div data-action="save-webp">Save as WebP</div>
    </div>
  </div>
  <div class="menu-item" data-menu="edit">Edit
    <div class="menu-dropdown">
      <div data-action="undo">Undo <span class="shortcut">Ctrl+Z</span></div>
      <div data-action="redo">Redo <span class="shortcut">Ctrl+Y</span></div>
      <div class="sep"></div>
      <div data-action="cut">Cut <span class="shortcut">Ctrl+X</span></div>
      <div data-action="copy">Copy <span class="shortcut">Ctrl+C</span></div>
      <div data-action="paste">Paste <span class="shortcut">Ctrl+V</span></div>
      <div class="sep"></div>
      <div data-action="select-all">Select All <span class="shortcut">Ctrl+A</span></div>
      <div data-action="deselect">Deselect <span class="shortcut">Esc</span></div>
      <div data-action="crop">Crop to Selection</div>
    </div>
  </div>
  <div class="menu-item" data-menu="view">View
    <div class="menu-dropdown">
      <div data-action="zoom-in">Zoom In <span class="shortcut">Ctrl++</span></div>
      <div data-action="zoom-out">Zoom Out <span class="shortcut">Ctrl+-</span></div>
      <div data-action="zoom-reset">Reset Zoom <span class="shortcut">Ctrl+0</span></div>
    </div>
  </div>
  <div class="menu-item" data-menu="image">Image
    <div class="menu-dropdown">
      <div data-action="flip-h">Flip Horizontal</div>
      <div data-action="flip-v">Flip Vertical</div>
      <div data-action="rotate-cw">Rotate 90° CW</div>
      <div data-action="rotate-ccw">Rotate 90° CCW</div>
      <div class="sep"></div>
      <div data-action="clear-canvas">Clear Canvas <span class="shortcut">Del</span></div>
    </div>
  </div>
  <div style="display:flex;align-items:center;gap:6px;margin-left:auto">
    <label class="dm-switch" title="Toggle dark mode">
      <input type="checkbox" id="darkToggle">
      <span class="dm-track"><span class="dm-knob"></span></span>
      <span id="dmLabel">Dark</span>
    </label>
    <button id="help-btn" title="Shortcuts &amp; features (?)">?</button>
  </div>
</div>

<!-- TOOLBAR -->
<div id="toolbar">
  <div class="tool-group">
    <div class="tool-btn-drop">
      <button class="tool-btn" data-tool="select" title="Select (S)" id="selectBtn">
        <svg id="selectIcon" viewBox="0 0 18 18"><rect x="2" y="2" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-dasharray="3 2"/></svg>
        <span>Select</span>
      </button>
      <button class="drop-arrow" id="selectDropArrow" title="Selection mode">&#9662;</button>
      <div class="drop-menu" id="selectDropMenu">
        <div data-selmode="rect" class="dm-active">
          <svg viewBox="0 0 16 16"><rect x="1" y="1" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.4" stroke-dasharray="3 2"/></svg>
          Rectangle
        </div>
        <div data-selmode="ellipse">
          <svg viewBox="0 0 16 16"><ellipse cx="8" cy="8" rx="7" ry="6" fill="none" stroke="currentColor" stroke-width="1.4" stroke-dasharray="3 2"/></svg>
          Ellipse
        </div>
      </div>
    </div>
    <button class="tool-btn" data-tool="pencil" title="Pencil (P)">
      <svg viewBox="0 0 18 18"><path d="M3 15l1.5-4L13 2.5l2.5 2.5L7 13.5z" fill="none" stroke="currentColor" stroke-width="1.3"/><path d="M3 15l1-1" stroke="currentColor" stroke-width="2"/></svg>
      <span>Pencil</span>
    </button>
    <button class="tool-btn" data-tool="eraser" title="Eraser (E)">
      <svg viewBox="0 0 18 18"><rect x="3" y="7" width="12" height="7" rx="1" fill="none" stroke="currentColor" stroke-width="1.3"/><line x1="3" y1="11" x2="15" y2="11" stroke="currentColor" stroke-width="1"/></svg>
      <span>Eraser</span>
    </button>
    <button class="tool-btn" data-tool="fill" title="Fill (F)">
      <svg viewBox="0 0 18 18"><path d="M5 14l-1-6 7-5 4 4-5 7z" fill="none" stroke="currentColor" stroke-width="1.3"/><path d="M14 11q2 2 0 4t0-4" fill="currentColor"/></svg>
      <span>Fill</span>
    </button>
  </div>
  <div class="tool-group">
    <button class="tool-btn" data-tool="line" title="Line (L)">
      <svg viewBox="0 0 18 18"><line x1="3" y1="15" x2="15" y2="3" stroke="currentColor" stroke-width="1.5"/></svg>
      <span>Line</span>
    </button>
    <div class="tool-btn-drop">
      <button class="tool-btn" data-tool="rect" title="Rectangle (R)" id="rectBtn">
        <svg id="rectIcon" viewBox="0 0 18 18"><rect x="2" y="4" width="14" height="10" fill="none" stroke="currentColor" stroke-width="1.5"/></svg>
        <span>Rectangle</span>
      </button>
      <button class="drop-arrow" id="rectDropArrow" title="Rectangle mode">&#9662;</button>
      <div class="drop-menu" id="rectDropMenu">
        <div data-rectmode="sharp" class="dm-active">
          <svg viewBox="0 0 16 16"><rect x="1" y="3" width="14" height="10" fill="none" stroke="currentColor" stroke-width="1.4"/></svg>
          Sharp corners
        </div>
        <div data-rectmode="rounded">
          <svg viewBox="0 0 16 16"><rect x="1" y="3" width="14" height="10" rx="3" fill="none" stroke="currentColor" stroke-width="1.4"/></svg>
          Rounded corners
        </div>
      </div>
    </div>
    <button class="tool-btn" data-tool="ellipse" title="Ellipse (O)">
      <svg viewBox="0 0 18 18"><ellipse cx="9" cy="9" rx="7" ry="5" fill="none" stroke="currentColor" stroke-width="1.5"/></svg>
      <span>Ellipse</span>
    </button>
    <button class="tool-btn" data-tool="text" title="Text (T)">
      <svg viewBox="0 0 18 18"><text x="4" y="14" font-size="14" font-weight="bold" fill="currentColor">A</text></svg>
      <span>Text</span>
    </button>
    <button class="tool-btn" data-tool="picker" title="Color Picker (I)">
      <svg viewBox="0 0 18 18"><path d="M7 16l-3-1 1-3 7-7 2.5 2.5z" fill="none" stroke="currentColor" stroke-width="1.3"/><circle cx="13" cy="4" r="2" fill="none" stroke="currentColor" stroke-width="1.2"/></svg>
      <span>Pick</span>
    </button>
  </div>
  <div class="tool-group shape-style-group" id="shapeStyleGroup" style="display:none">
    <span class="tool-label">Style:</span>
    <button class="shape-btn active" data-shapestyle="stroke" title="Outline">
      <svg viewBox="0 0 18 18"><rect x="2" y="4" width="14" height="10" fill="none" stroke="currentColor" stroke-width="1.5"/></svg>
    </button>
    <button class="shape-btn" data-shapestyle="fill" title="Filled">
      <svg viewBox="0 0 18 18"><rect x="2" y="4" width="14" height="10" fill="currentColor"/></svg>
    </button>
    <button class="shape-btn" data-shapestyle="both" title="Outline + Fill">
      <svg viewBox="0 0 18 18"><rect x="2" y="4" width="14" height="10" fill="#aaa" stroke="currentColor" stroke-width="1.5"/></svg>
    </button>
  </div>
  <div class="tool-group">
    <span class="tool-label">Size:</span>
    <button class="size-btn" id="brushMinus" title="Decrease size">&#8722;</button>
    <input type="range" id="brushSize" min="1" max="100" value="2">
    <button class="size-btn" id="brushPlus" title="Increase size">+</button>
    <input type="number" id="brushSizeVal" value="2" min="1" max="100">
  </div>
  <div class="tool-group" id="fontGroup" style="display:none">
    <span class="tool-label">Font:</span>
    <select id="fontFamily">
      <option value="sans-serif" style="font-family:sans-serif">Sans-serif</option>
      <option value="Arial" style="font-family:Arial">Arial</option>
      <option value="Helvetica" style="font-family:Helvetica">Helvetica</option>
      <option value="Verdana" style="font-family:Verdana">Verdana</option>
      <option value="Tahoma" style="font-family:Tahoma">Tahoma</option>
      <option value="Trebuchet MS" style="font-family:Trebuchet MS">Trebuchet MS</option>
      <option value="serif" style="font-family:serif">Serif</option>
      <option value="Times New Roman" style="font-family:Times New Roman">Times New Roman</option>
      <option value="Georgia" style="font-family:Georgia">Georgia</option>
      <option value="Garamond" style="font-family:Garamond">Garamond</option>
      <option value="monospace" style="font-family:monospace">Monospace</option>
      <option value="Courier New" style="font-family:Courier New">Courier New</option>
      <option value="Consolas" style="font-family:Consolas">Consolas</option>
      <option value="Lucida Console" style="font-family:Lucida Console">Lucida Console</option>
      <option value="Comic Sans MS" style="font-family:Comic Sans MS">Comic Sans MS</option>
      <option value="Impact" style="font-family:Impact">Impact</option>
      <option value="Rubik" style="font-family:Rubik">Rubik</option>
    </select>
    <span class="tool-label">Size:</span>
    <button class="size-btn" id="fontMinus" title="Decrease font size">&#8722;</button>
    <input type="number" id="fontSizeInput" min="8" max="200" value="20">
    <button class="size-btn" id="fontPlus" title="Increase font size">+</button>
    <label class="fmt-cb"><input type="checkbox" id="fontBold"> <b>Bold</b></label>
    <label class="fmt-cb"><input type="checkbox" id="fontItalic"> <i>Italic</i></label>
    <label class="fmt-cb"><input type="checkbox" id="fontUnderline"> <u>Underline</u></label>
    <label class="fmt-cb"><input type="checkbox" id="fontStrike"> <s>Strikethrough</s></label>
  </div>
</div>

<!-- WORKSPACE -->
<div id="workspace">
  <div id="dropzone">Drop image here</div>
  <div id="canvas-area">
    <canvas id="canvas" width="800" height="600"></canvas>
    <canvas id="overlay"></canvas>
    <div class="resize-handle" id="resize-se"></div>
    <div class="resize-handle" id="resize-s"></div>
    <div class="resize-handle" id="resize-e"></div>
    <div id="text-wrapper">
      <div id="text-bar"><button id="text-commit" title="Commit text (✓)">&#10003;</button></div>
      <div id="text-content" contenteditable="true"></div>
    </div>
  </div>
</div>

<!-- BOTTOM BAR -->
<div id="bottombar">
  <div id="color-display">
    <div id="fg-bg-box">
      <div id="fg-color-box" title="Foreground color (left click)"></div>
      <div id="bg-color-box" title="Background color (right click)"></div>
    </div>
    <button id="swap-colors" title="Swap colors (X)">&#8644;</button>
  </div>
  <div class="bar-sep"></div>
  <div id="palette"></div>
  <div class="bar-sep"></div>
  <div id="statusbar">
    <span id="stat-pos">0, 0</span>
    <div id="size-edit">
      <div class="dim-group">
        <button class="dim-btn left" data-dim="w" data-delta="-1">&#8722;</button>
        <input type="number" id="sizeW" value="800" min="1" max="9999" title="Canvas width">
        <button class="dim-btn right" data-dim="w" data-delta="1">+</button>
      </div>
      <span class="size-x">&times;</span>
      <div class="dim-group">
        <button class="dim-btn left" data-dim="h" data-delta="-1">&#8722;</button>
        <input type="number" id="sizeH" value="600" min="1" max="9999" title="Canvas height">
        <button class="dim-btn right" data-dim="h" data-delta="1">+</button>
      </div>
    </div>
    <div id="zoom-controls">
      <button class="zbtn" id="zoomMinus" title="Zoom out 5%">&#8722;</button>
      <span id="stat-zoom">100%</span>
      <button class="zbtn" id="zoomPlus" title="Zoom in 5%">+</button>
    </div>
  </div>
</div>

<div id="help-overlay">
  <div id="help-panel">
    <button id="help-close">&times;</button>
    <h2>Shortcuts &amp; Features</h2>

    <div class="hgroup">
      <h3>Tools</h3>
      <div class="hrow"><span class="hkey">S</span><span class="hdesc">Select</span></div>
      <div class="hrow"><span class="hkey">P</span><span class="hdesc">Pencil</span></div>
      <div class="hrow"><span class="hkey">E</span><span class="hdesc">Eraser</span></div>
      <div class="hrow"><span class="hkey">F</span><span class="hdesc">Fill (bucket)</span></div>
      <div class="hrow"><span class="hkey">L</span><span class="hdesc">Line</span></div>
      <div class="hrow"><span class="hkey">R</span><span class="hdesc">Rectangle</span></div>
      <div class="hrow"><span class="hkey">O</span><span class="hdesc">Ellipse</span></div>
      <div class="hrow"><span class="hkey">T</span><span class="hdesc">Text (drag to set box size, drag bar to move, &#10003; to commit)</span></div>
      <div class="hrow"><span class="hkey">I</span><span class="hdesc">Color picker (eyedropper)</span></div>
      <div class="hrow"><span class="hkey">Left click</span><span class="hdesc">Draw with foreground color</span></div>
      <div class="hrow"><span class="hkey">Right click</span><span class="hdesc">Draw with background color</span></div>
      <div class="hrow"><span class="hkey">Shift + drag</span><span class="hdesc">Constrain (square, circle, 45&deg; lines)</span></div>
    </div>

    <div class="hgroup">
      <h3>Selection</h3>
      <div class="hrow"><span class="hkey">Ctrl + drag selection</span><span class="hdesc">Copy selection (original stays in place)</span></div>
      <div class="hrow"><span class="hkey">Ctrl + C / X / V</span><span class="hdesc">Copy / Cut / Paste (also system clipboard)</span></div>
      <div class="hrow"><span class="hkey">Ctrl + A</span><span class="hdesc">Select all</span></div>
      <div class="hrow"><span class="hkey">Esc</span><span class="hdesc">Deselect / cancel</span></div>
      <div class="hrow"><span class="hkey">Delete</span><span class="hdesc">Delete selection (or clear canvas)</span></div>
    </div>

    <div class="hgroup">
      <h3>Colors</h3>
      <div class="hrow"><span class="hkey">Palette left click</span><span class="hdesc">Set foreground color</span></div>
      <div class="hrow"><span class="hkey">Palette right click</span><span class="hdesc">Set background color</span></div>
      <div class="hrow"><span class="hkey">&#8644; button</span><span class="hdesc">Swap foreground &amp; background colors</span></div>
      <div class="hrow"><span class="hkey">Click FG/BG box</span><span class="hdesc">Open custom color picker</span></div>
    </div>

    <div class="hgroup">
      <h3>Navigation</h3>
      <div class="hrow"><span class="hkey">Ctrl + Scroll</span><span class="hdesc">Zoom in / out (5% steps)</span></div>
      <div class="hrow"><span class="hkey">Ctrl + + / Ctrl + -</span><span class="hdesc">Zoom in / out</span></div>
      <div class="hrow"><span class="hkey">Ctrl + 0</span><span class="hdesc">Reset zoom to 100%</span></div>
    </div>

    <div class="hgroup">
      <h3>Images</h3>
      <div class="hrow"><span class="hkey">Drag &amp; drop</span><span class="hdesc">Insert image as floating selection</span></div>
      <div class="hrow"><span class="hkey">Ctrl + V</span><span class="hdesc">Paste image from clipboard</span></div>
      <div class="hrow"><span class="hkey">Ctrl + O</span><span class="hdesc">Open image file</span></div>
    </div>

    <div class="hgroup">
      <h3>Canvas</h3>
      <div class="hrow"><span class="hkey">Drag corner/edge handles</span><span class="hdesc">Resize canvas with mouse</span></div>
      <div class="hrow"><span class="hkey">Size inputs (bottom bar)</span><span class="hdesc">Type exact canvas dimensions in pixels</span></div>
    </div>

    <div class="hgroup">
      <h3>File</h3>
      <div class="hrow"><span class="hkey">Ctrl + N</span><span class="hdesc">New canvas</span></div>
      <div class="hrow"><span class="hkey">Ctrl + S</span><span class="hdesc">Save as PNG</span></div>
      <div class="hrow"><span class="hkey">Ctrl + Z / Y</span><span class="hdesc">Undo / Redo</span></div>
    </div>
  </div>
</div>

<div id="confirm-dialog">
  <div class="dialog-box">
    <p id="confirm-msg"></p>
    <div class="dialog-btns">
      <button id="confirm-no">No</button>
      <button id="confirm-yes" class="primary">Yes</button>
    </div>
  </div>
</div>

<input type="file" id="fileInput" accept="image/*">
<input type="color" id="colorPicker">

<script>
// ============================================================
// STATE
// ============================================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', {willReadFrequently: true});
const overlay = document.getElementById('overlay');
const octx = overlay.getContext('2d');
const canvasArea = document.getElementById('canvas-area');
const workspace = document.getElementById('workspace');

let currentTool = 'pencil';
let fgColor = '#000000';
let bgColor = '#ffffff';
let brushSize = 2;
let zoom = 1;
let shapeStyle = 'stroke'; // stroke, fill, both
let rectMode = 'sharp'; // 'sharp' or 'rounded'

// Drawing state
let isDrawing = false;
let startX = 0, startY = 0;
let lastX = 0, lastY = 0;
let drawButton = 0; // 0=left, 2=right

// History
const undoStack = [];
const redoStack = [];
const MAX_UNDO = 40;

// Selection
let selectMode = 'rect'; // 'rect' or 'ellipse'
let sel = null; // {x, y, w, h, data: ImageData|null, floating: bool}
let selDragStart = null;
let marchOffset = 0;
let marchInterval = null;

// Clipboard (internal)
let clipboard = null; // ImageData

// Resize
let resizing = null; // 'se'|'s'|'e'
let resizeStart = null;

// Text
let textActive = false;

// ============================================================
// UTILITIES
// ============================================================
function getCoords(e) {
  const r = canvas.getBoundingClientRect();
  return {
    x: Math.floor((e.clientX - r.left) / zoom),
    y: Math.floor((e.clientY - r.top) / zoom)
  };
}

function hexToRgb(hex) {
  const v = parseInt(hex.slice(1), 16);
  return {r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255};
}

function rgbToHex(r, g, b) {
  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

function drawColor(button) {
  return button === 2 ? bgColor : fgColor;
}

function clamp(v, mn, mx) { return Math.max(mn, Math.min(mx, v)); }

// ============================================================
// CANVAS MANAGEMENT
// ============================================================
function syncOverlay() {
  overlay.width = canvas.width;
  overlay.height = canvas.height;
  applyZoom();
}

function applyZoom() {
  const w = canvas.width * zoom;
  const h = canvas.height * zoom;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  overlay.style.width = w + 'px';
  overlay.style.height = h + 'px';
  document.getElementById('stat-zoom').textContent = Math.round(zoom * 100) + '%';
}

function setZoom(z) {
  zoom = clamp(z, 0.05, 32);
  applyZoom();
  drawMarchingAnts();
}

function resizeCanvas(newW, newH) {
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  canvas.width = newW;
  canvas.height = newH;
  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, newW, newH);
  ctx.putImageData(imgData, 0, 0);
  syncOverlay();
  updateSizeStatus();
}

function updateSizeStatus() {
  document.getElementById('sizeW').value = canvas.width;
  document.getElementById('sizeH').value = canvas.height;
}

function updatePosStatus(x, y) {
  document.getElementById('stat-pos').textContent = x + ', ' + y;
}

// ============================================================
// HISTORY
// ============================================================
function saveState() {
  undoStack.push(canvas.toDataURL());
  if (undoStack.length > MAX_UNDO) undoStack.shift();
  redoStack.length = 0;
}

function restoreFromDataURL(dataUrl) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      syncOverlay();
      updateSizeStatus();
      resolve();
    };
    img.src = dataUrl;
  });
}

function undo() {
  if (!undoStack.length) return;
  redoStack.push(canvas.toDataURL());
  restoreFromDataURL(undoStack.pop());
}

function redo() {
  if (!redoStack.length) return;
  undoStack.push(canvas.toDataURL());
  restoreFromDataURL(redoStack.pop());
}

// ============================================================
// FLOOD FILL
// ============================================================
function floodFill(sx, sy, color) {
  const w = canvas.width, h = canvas.height;
  const imageData = ctx.getImageData(0, 0, w, h);
  const d = imageData.data;
  const i0 = (sy * w + sx) * 4;
  const sr = d[i0], sg = d[i0+1], sb = d[i0+2], sa = d[i0+3];
  const f = hexToRgb(color);
  if (sr === f.r && sg === f.g && sb === f.b && sa === 255) return;

  const match = i => d[i] === sr && d[i+1] === sg && d[i+2] === sb && d[i+3] === sa;
  const set = i => { d[i] = f.r; d[i+1] = f.g; d[i+2] = f.b; d[i+3] = 255; };

  const stack = [[sx, sy]];
  while (stack.length) {
    let [x, y] = stack.pop();
    while (x > 0 && match((y * w + x - 1) * 4)) x--;
    let spanU = false, spanD = false;
    while (x < w) {
      const idx = (y * w + x) * 4;
      if (!match(idx)) break;
      set(idx);
      const u = y > 0 && match(((y-1) * w + x) * 4);
      const dn = y < h-1 && match(((y+1) * w + x) * 4);
      if (u && !spanU) { stack.push([x, y-1]); spanU = true; }
      else if (!u) spanU = false;
      if (dn && !spanD) { stack.push([x, y+1]); spanD = true; }
      else if (!dn) spanD = false;
      x++;
    }
  }
  ctx.putImageData(imageData, 0, 0);
}

// ============================================================
// SELECTION & MARCHING ANTS
// ============================================================
function commitSelection() {
  if (!sel) return;
  if (sel.data && sel.floating) {
    // Use temp canvas + drawImage for proper alpha compositing (ellipse transparency)
    const tmp = document.createElement('canvas');
    tmp.width = sel.w; tmp.height = sel.h;
    tmp.getContext('2d').putImageData(sel.data, 0, 0);
    ctx.drawImage(tmp, sel.x, sel.y);
  }
  sel = null;
  clearOverlay();
  stopMarch();
}

function startMarch() {
  stopMarch();
  marchOffset = 0;
  marchInterval = setInterval(() => {
    marchOffset = (marchOffset + 1) % 16;
    drawMarchingAnts();
  }, 150);
}

function stopMarch() {
  if (marchInterval) { clearInterval(marchInterval); marchInterval = null; }
  clearOverlay();
}

function drawMarchingAnts() {
  clearOverlay();
  if (!sel) return;
  const isEllipse = (sel._mode || selectMode) === 'ellipse';

  function drawAnts() {
    octx.save();
    octx.lineWidth = 1;
    octx.setLineDash([4, 4]);
    if (isEllipse) {
      const cx = sel.x + sel.w / 2, cy = sel.y + sel.h / 2;
      octx.lineDashOffset = -marchOffset;
      octx.strokeStyle = '#000';
      octx.beginPath(); octx.ellipse(cx, cy, sel.w / 2, sel.h / 2, 0, 0, Math.PI * 2); octx.stroke();
      octx.lineDashOffset = -marchOffset + 4;
      octx.strokeStyle = '#fff';
      octx.beginPath(); octx.ellipse(cx, cy, sel.w / 2, sel.h / 2, 0, 0, Math.PI * 2); octx.stroke();
    } else {
      octx.lineDashOffset = -marchOffset;
      octx.strokeStyle = '#000';
      octx.strokeRect(sel.x + 0.5, sel.y + 0.5, sel.w - 1, sel.h - 1);
      octx.lineDashOffset = -marchOffset + 4;
      octx.strokeStyle = '#fff';
      octx.strokeRect(sel.x + 0.5, sel.y + 0.5, sel.w - 1, sel.h - 1);
    }
    octx.restore();
  }

  drawAnts();
  // Draw floating image preview
  if (sel.data && sel.floating) {
    const tmp = document.createElement('canvas');
    tmp.width = sel.w; tmp.height = sel.h;
    tmp.getContext('2d').putImageData(sel.data, 0, 0);
    octx.drawImage(tmp, sel.x, sel.y);
    drawAnts(); // re-draw ants on top
  }
}

function clearOverlay() {
  octx.clearRect(0, 0, overlay.width, overlay.height);
}

function liftSelection(copyMode) {
  if (!sel || sel.floating) return;
  sel._mode = selectMode; // remember which mode was used
  sel.data = ctx.getImageData(sel.x, sel.y, sel.w, sel.h);
  sel.floating = true;

  // Apply ellipse mask: make pixels outside ellipse transparent
  if (selectMode === 'ellipse') {
    const d = sel.data.data;
    const cx = sel.w / 2, cy = sel.h / 2;
    const rx = sel.w / 2, ry = sel.h / 2;
    for (let py = 0; py < sel.h; py++) {
      for (let px = 0; px < sel.w; px++) {
        const dx = (px + 0.5 - cx) / rx, dy = (py + 0.5 - cy) / ry;
        if (dx * dx + dy * dy > 1) {
          d[(py * sel.w + px) * 4 + 3] = 0;
        }
      }
    }
  }

  if (!copyMode) {
    if (selectMode === 'ellipse') {
      ctx.save();
      ctx.fillStyle = bgColor;
      ctx.beginPath();
      ctx.ellipse(sel.x + sel.w / 2, sel.y + sel.h / 2, sel.w / 2, sel.h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    } else {
      ctx.fillStyle = bgColor;
      ctx.fillRect(sel.x, sel.y, sel.w, sel.h);
    }
  }
}

function insideSelection(x, y) {
  if (!sel) return false;
  const mode = sel._mode || selectMode;
  if (mode === 'ellipse') {
    const cx = sel.x + sel.w / 2, cy = sel.y + sel.h / 2;
    const rx = sel.w / 2, ry = sel.h / 2;
    if (rx <= 0 || ry <= 0) return false;
    const dx = (x - cx) / rx, dy = (y - cy) / ry;
    return dx * dx + dy * dy <= 1;
  }
  return x >= sel.x && x < sel.x + sel.w && y >= sel.y && y < sel.y + sel.h;
}

function selectAll() {
  commitSelection();
  sel = {x: 0, y: 0, w: canvas.width, h: canvas.height, data: null, floating: false};
  startMarch();
}

function cropToSelection() {
  if (!sel) return;
  const data = sel.floating && sel.data ? sel.data : ctx.getImageData(sel.x, sel.y, sel.w, sel.h);
  saveState();
  canvas.width = sel.w;
  canvas.height = sel.h;
  ctx.putImageData(data, 0, 0);
  sel = null;
  stopMarch();
  syncOverlay();
  updateSizeStatus();
}

// ============================================================
// CLIPBOARD
// ============================================================
function copySelection() {
  if (!sel) return;
  if (sel.floating && sel.data) {
    clipboard = sel.data;
  } else {
    clipboard = ctx.getImageData(sel.x, sel.y, sel.w, sel.h);
  }
  // Also copy to system clipboard
  try {
    const tmp = document.createElement('canvas');
    tmp.width = clipboard.width; tmp.height = clipboard.height;
    tmp.getContext('2d').putImageData(clipboard, 0, 0);
    tmp.toBlob(blob => {
      if (blob) navigator.clipboard.write([new ClipboardItem({'image/png': blob})]).catch(() => {});
    });
  } catch(e) {}
}

function cutSelection() {
  if (!sel) return;
  copySelection();
  saveState();
  if (sel.floating) {
    // Just remove the floating selection without stamping
    sel = null;
    stopMarch();
  } else {
    ctx.fillStyle = bgColor;
    ctx.fillRect(sel.x, sel.y, sel.w, sel.h);
    sel = null;
    stopMarch();
  }
}

function pasteClipboard(imgData) {
  const data = imgData || clipboard;
  if (!data) return;
  commitSelection();
  saveState();
  sel = {x: 0, y: 0, w: data.width, h: data.height, data: data, floating: true};
  startMarch();
  drawMarchingAnts();
  setTool('select');
}

// ============================================================
// TEXT TOOL
// ============================================================
const textWrapper = document.getElementById('text-wrapper');
const textContent = document.getElementById('text-content');
const textBar = document.getElementById('text-bar');

// Use <br> for Enter instead of <div> — preserves inline formatting (bold, italic, etc.)
textContent.addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    e.preventDefault();
    document.execCommand('insertLineBreak');
  }
});

function showTextInput(x, y, w, h) {
  commitText();
  textActive = true;
  const fontSize = parseInt(document.getElementById('fontSizeInput').value) || 20;
  textWrapper.style.display = 'block';
  textWrapper.style.left = (x * zoom) + 'px';
  textWrapper.style.top = (y * zoom - 18) + 'px'; // 18px = bar height, position bar above box
  textContent.style.width = (w * zoom) + 'px';
  textContent.style.height = (h * zoom) + 'px';
  textWrapper._cx = x;
  textWrapper._cy = y;
  applyTextFormat();
  textContent.innerHTML = '';
  setTimeout(() => textContent.focus(), 10);
}

function applyTextFormat() {
  const fontSize = parseInt(document.getElementById('fontSizeInput').value) || 20;
  const bold = document.getElementById('fontBold').checked;
  const italic = document.getElementById('fontItalic').checked;
  const underline = document.getElementById('fontUnderline').checked;
  const strike = document.getElementById('fontStrike').checked;
  const fontFam = document.getElementById('fontFamily').value;
  textContent.style.fontSize = (fontSize * zoom) + 'px';
  textContent.style.fontFamily = fontFam;
  textContent.style.fontWeight = bold ? 'bold' : 'normal';
  textContent.style.fontStyle = italic ? 'italic' : 'normal';
  const deco = [];
  if (underline) deco.push('underline');
  if (strike) deco.push('line-through');
  textContent.style.textDecoration = deco.length ? deco.join(' ') : 'none';
  textContent.style.color = fgColor;
}

function getNodeStyle(node) {
  const el = node.nodeType === 3 ? node.parentElement : node;
  const cs = window.getComputedStyle(el);
  const color = cs.color;
  const bold = parseInt(cs.fontWeight) >= 700;
  const italic = cs.fontStyle === 'italic';
  const fontSize = parseFloat(cs.fontSize); // screen pixels
  const fontFamily = cs.fontFamily; // computed font family
  // text-decoration doesn't inherit, walk up ancestors
  let underline = false, strike = false;
  let cur = el;
  while (cur && cur !== textContent.parentElement) {
    const dl = (window.getComputedStyle(cur).textDecorationLine || window.getComputedStyle(cur).textDecoration || '');
    if (dl.includes('underline')) underline = true;
    if (dl.includes('line-through')) strike = true;
    cur = cur.parentElement;
  }
  return {color, bold, italic, underline, strike, fontSize, fontFamily};
}

function getVisualLines() {
  // Extract visual lines with per-segment formatting and exact Y positions
  const text = textContent.innerText;
  if (!text) return [];

  const contentRect = textContent.getBoundingClientRect();
  const lines = []; // [{segs: [...], yOffset: px from content top}]
  const range = document.createRange();
  let lastTop = null;
  let currentLine = [];
  let lineY = 0;

  function walkTextNodes(el) {
    for (const child of el.childNodes) {
      if (child.nodeType === 3) { // Text node
        const style = getNodeStyle(child);
        const key = style.color + style.bold + style.italic + style.underline + style.strike + style.fontSize + style.fontFamily;
        for (let i = 0; i < child.textContent.length; i++) {
          range.setStart(child, i);
          range.setEnd(child, i + 1);
          const rect = range.getBoundingClientRect();
          if (lastTop !== null && Math.abs(rect.top - lastTop) > 2) {
            lines.push({segs: currentLine, yOffset: lineY});
            currentLine = [];
            lineY = rect.top - contentRect.top;
          }
          if (lastTop === null) lineY = rect.top - contentRect.top;
          const last = currentLine[currentLine.length - 1];
          if (last && last._key === key) {
            last.text += child.textContent[i];
          } else {
            currentLine.push({text: child.textContent[i], ...style, _key: key});
          }
          lastTop = rect.top;
        }
      } else if (child.nodeName === 'BR' || child.nodeName === 'DIV') {
        if (currentLine.length || lines.length > 0) lines.push({segs: currentLine, yOffset: lineY});
        currentLine = [];
        lastTop = null;
        if (child.childNodes.length) walkTextNodes(child);
      } else {
        walkTextNodes(child);
      }
    }
  }
  walkTextNodes(textContent);
  if (currentLine.length) lines.push({segs: currentLine, yOffset: lineY});
  return lines;
}

function commitText() {
  if (!textActive) return;
  const text = textContent.innerText;
  if (text.trim()) {
    saveState();
    ctx.save();
    ctx.textBaseline = 'top';
    const cs = window.getComputedStyle(textContent);
    const padL = parseFloat(cs.paddingLeft);
    const padT = parseFloat(cs.paddingTop);
    const borL = parseFloat(cs.borderLeftWidth) || 0;
    const baseX = textWrapper._cx + (padL + borL) / zoom;
    const baseY = textWrapper._cy + padT / zoom;
    const wrapped = getVisualLines();
    for (const line of wrapped) {
      const y = baseY + line.yOffset / zoom;
      let lx = baseX;
      for (const seg of line.segs) {
        // Per-segment font size (screen px → canvas px)
        const sz = seg.fontSize / zoom;
        const segFont = (seg.italic ? 'italic ' : '') + (seg.bold ? 'bold ' : '') + sz + 'px ' + seg.fontFamily;
        ctx.font = segFont;
        ctx.fillStyle = seg.color;
        ctx.fillText(seg.text, lx, y);
        const segW = ctx.measureText(seg.text).width;
        if (seg.underline || seg.strike) {
          ctx.save();
          ctx.strokeStyle = seg.color;
          ctx.lineWidth = Math.max(1, sz / 15);
          if (seg.underline) {
            const uy = y + sz * 1.08;
            ctx.beginPath(); ctx.moveTo(lx, uy); ctx.lineTo(lx + segW, uy); ctx.stroke();
          }
          if (seg.strike) {
            const sy = y + sz * 0.55;
            ctx.beginPath(); ctx.moveTo(lx, sy); ctx.lineTo(lx + segW, sy); ctx.stroke();
          }
          ctx.restore();
        }
        lx += segW;
      }
    }
    ctx.restore();
  }
  textWrapper.style.display = 'none';
  textContent.innerHTML = '';
  textActive = false;
}

// Text bar drag to reposition
let textDrag = null;
textBar.addEventListener('mousedown', e => {
  if (e.target.id === 'text-commit') return;
  e.preventDefault();
  textDrag = {mx: e.clientX, my: e.clientY, ox: textWrapper.offsetLeft, oy: textWrapper.offsetTop};
});
document.addEventListener('mousemove', e => {
  if (!textDrag) return;
  const dx = e.clientX - textDrag.mx, dy = e.clientY - textDrag.my;
  textWrapper.style.left = (textDrag.ox + dx) + 'px';
  textWrapper.style.top = (textDrag.oy + dy) + 'px';
  textWrapper._cx = parseFloat(textWrapper.style.left) / zoom;
  textWrapper._cy = (parseFloat(textWrapper.style.top) + 18) / zoom; // 18px bar offset
});
document.addEventListener('mouseup', () => { textDrag = null; });

// Commit button
document.getElementById('text-commit').addEventListener('click', () => commitText());

// Live format updates - selection-sensitive
const fmtCmdMap = {fontBold:'bold', fontItalic:'italic', fontUnderline:'underline', fontStrike:'strikeThrough'};
// Prevent focus loss when clicking format checkboxes
document.getElementById('fontGroup').addEventListener('mousedown', e => {
  if (textActive && e.target.tagName !== 'SELECT') e.preventDefault();
});
Object.keys(fmtCmdMap).forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    if (!textActive) return;
    const s = window.getSelection();
    const hasSel = s.rangeCount && !s.isCollapsed && textContent.contains(s.anchorNode);
    if (hasSel) {
      // Apply to selection only via execCommand
      const cmd = fmtCmdMap[id];
      const want = document.getElementById(id).checked;
      const cur = document.queryCommandState(cmd);
      if (want !== cur) document.execCommand(cmd, false, null);
    } else {
      // No selection: apply to whole div as default for new text
      applyTextFormat();
    }
    textContent.focus();
  });
});
// Font size - selection-sensitive
function setSelectionFontSize(sizePx) {
  // execCommand fontSize only accepts 1-7, so use it as a marker then replace
  document.execCommand('fontSize', false, 1);
  const screenPx = sizePx * zoom;
  textContent.querySelectorAll('font[size="1"]').forEach(el => {
    el.removeAttribute('size');
    el.style.fontSize = screenPx + 'px';
  });
}
document.getElementById('fontSizeInput').addEventListener('input', () => {
  if (!textActive) return;
  const size = parseInt(document.getElementById('fontSizeInput').value) || 20;
  const s = window.getSelection();
  const hasSel = s.rangeCount && !s.isCollapsed && textContent.contains(s.anchorNode);
  if (hasSel) {
    setSelectionFontSize(size);
  } else {
    applyTextFormat();
  }
});
// Font family - selection-sensitive
document.getElementById('fontFamily').addEventListener('mousedown', e => {
  if (textActive) {
    // Save selection before dropdown opens (it will steal focus)
    const s = window.getSelection();
    if (s.rangeCount && !s.isCollapsed && textContent.contains(s.anchorNode)) {
      textContent._savedRange = s.getRangeAt(0).cloneRange();
    }
  }
});
document.getElementById('fontFamily').addEventListener('change', () => {
  if (!textActive) return;
  const font = document.getElementById('fontFamily').value;
  // Restore saved selection if any
  const saved = textContent._savedRange;
  if (saved) {
    const s = window.getSelection();
    s.removeAllRanges();
    s.addRange(saved);
    textContent._savedRange = null;
    document.execCommand('fontName', false, font);
  } else {
    applyTextFormat();
  }
  textContent.focus();
});

// ============================================================
// DRAWING HELPERS
// ============================================================
function drawLineOnCtx(c, x1, y1, x2, y2, color, size) {
  c.save();
  c.strokeStyle = color;
  c.lineWidth = size;
  c.lineCap = 'round';
  c.lineJoin = 'round';
  c.beginPath();
  c.moveTo(x1, y1);
  c.lineTo(x2, y2);
  c.stroke();
  c.restore();
}

function roundRectPath(c, x, y, w, h, r) {
  r = Math.min(r, w / 2, h / 2);
  c.beginPath();
  c.moveTo(x + r, y);
  c.lineTo(x + w - r, y);
  c.arcTo(x + w, y, x + w, y + r, r);
  c.lineTo(x + w, y + h - r);
  c.arcTo(x + w, y + h, x + w - r, y + h, r);
  c.lineTo(x + r, y + h);
  c.arcTo(x, y + h, x, y + h - r, r);
  c.lineTo(x, y + r);
  c.arcTo(x, y, x + r, y, r);
  c.closePath();
}

function drawShapePreview(c, tool, x1, y1, x2, y2, color, fillCol, size, shift) {
  let lx = Math.min(x1, x2), ly = Math.min(y1, y2);
  let w = Math.abs(x2 - x1), h = Math.abs(y2 - y1);
  if (shift) { const s = Math.max(w, h); w = s; h = s; if (x2 < x1) lx = x1 - s; if (y2 < y1) ly = y1 - s; }
  c.save();
  c.lineWidth = size;
  c.lineCap = 'round';
  c.lineJoin = 'miter';

  if (tool === 'line') {
    let tx2 = x2, ty2 = y2;
    if (shift) {
      const dx = x2 - x1, dy = y2 - y1;
      const angle = Math.atan2(dy, dx);
      const snap = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
      const len = Math.hypot(dx, dy);
      tx2 = x1 + Math.cos(snap) * len;
      ty2 = y1 + Math.sin(snap) * len;
    }
    c.strokeStyle = color;
    c.beginPath();
    c.moveTo(x1, y1);
    c.lineTo(tx2, ty2);
    c.stroke();
  } else if (tool === 'rect') {
    const rounded = rectMode === 'rounded';
    const radius = rounded ? Math.max(size / 2 + 4, Math.min(Math.min(w, h) / 3, 12 + size / 2)) : 0;
    if (rounded) {
      c.lineJoin = 'round';
      roundRectPath(c, lx, ly, w, h, radius);
      if (shapeStyle === 'fill' || shapeStyle === 'both') { c.fillStyle = fillCol; c.fill(); }
      if (shapeStyle === 'stroke' || shapeStyle === 'both') { c.strokeStyle = color; c.stroke(); }
    } else {
      if (shapeStyle === 'fill' || shapeStyle === 'both') { c.fillStyle = fillCol; c.fillRect(lx, ly, w, h); }
      if (shapeStyle === 'stroke' || shapeStyle === 'both') { c.strokeStyle = color; c.strokeRect(lx, ly, w, h); }
    }
  } else if (tool === 'ellipse') {
    const cx = lx + w / 2, cy = ly + h / 2;
    c.beginPath();
    c.ellipse(cx, cy, w / 2, h / 2, 0, 0, Math.PI * 2);
    if (shapeStyle === 'fill' || shapeStyle === 'both') { c.fillStyle = fillCol; c.fill(); }
    if (shapeStyle === 'stroke' || shapeStyle === 'both') { c.strokeStyle = color; c.stroke(); }
  }
  c.restore();
}

// ============================================================
// TOOL SWITCHING
// ============================================================
function setTool(t) {
  if (currentTool === 'text' && t !== 'text') commitText();
  if (currentTool === 'select' && t !== 'select') commitSelection();
  currentTool = t;
  document.querySelectorAll('.tool-btn').forEach(b => b.classList.toggle('active', b.dataset.tool === t));

  const shapeTools = ['rect', 'ellipse'];
  document.getElementById('shapeStyleGroup').style.display = shapeTools.includes(t) ? 'flex' : 'none';
  document.getElementById('fontGroup').style.display = t === 'text' ? 'flex' : 'none';

  canvas.style.cursor =
    t === 'select' ? 'crosshair' :
    t === 'pencil' ? 'crosshair' :
    t === 'eraser' ? 'crosshair' :
    t === 'fill' ? 'crosshair' :
    t === 'text' ? 'text' :
    t === 'picker' ? 'crosshair' :
    'crosshair';
}

// ============================================================
// MOUSE EVENT HANDLERS
// ============================================================
let shiftHeld = false;
let ctrlHeld = false;

document.addEventListener('keydown', e => {
  shiftHeld = e.shiftKey;
  ctrlHeld = e.ctrlKey || e.metaKey;
});
document.addEventListener('keyup', e => {
  shiftHeld = e.shiftKey;
  ctrlHeld = e.ctrlKey || e.metaKey;
});

// -- Canvas mouse events --
canvas.addEventListener('mousedown', onCanvasMouseDown);
canvas.addEventListener('contextmenu', e => e.preventDefault());
document.addEventListener('mousemove', onDocMouseMove);
document.addEventListener('mouseup', onDocMouseUp);

function onCanvasMouseDown(e) {
  if (resizing) return;
  e.preventDefault();
  const {x, y} = getCoords(e);
  drawButton = e.button;

  if (currentTool === 'text') {
    if (textActive) commitText();
    isDrawing = true;
    startX = x; startY = y;
    return;
  }

  if (currentTool === 'picker') {
    const px = ctx.getImageData(x, y, 1, 1).data;
    const c = rgbToHex(px[0], px[1], px[2]);
    if (e.button === 2) { bgColor = c; updateColorDisplay(); }
    else { fgColor = c; updateColorDisplay(); }
    return;
  }

  if (currentTool === 'fill') {
    if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) return;
    saveState();
    floodFill(x, y, drawColor(e.button));
    return;
  }

  if (currentTool === 'select') {
    const isCtrl = e.ctrlKey || e.metaKey;
    if (sel && insideSelection(x, y)) {
      // Ctrl+drag on already-floating selection: stamp current copy, then drag a new one
      if (isCtrl && sel.floating && sel.data) {
        saveState();
        const tmp = document.createElement('canvas');
        tmp.width = sel.w; tmp.height = sel.h;
        tmp.getContext('2d').putImageData(sel.data, 0, 0);
        ctx.drawImage(tmp, sel.x, sel.y);
        // sel.data stays the same — it becomes the new copy to drag
      }
      selDragStart = {x, y, selX: sel.x, selY: sel.y, lifted: sel.floating, ctrl: isCtrl};
      isDrawing = true;
      return;
    }
    // Commit old selection, start new one
    commitSelection();
    startX = x; startY = y;
    sel = {x, y, w: 0, h: 0, data: null, floating: false};
    isDrawing = true;
    startMarch();
    return;
  }

  // Drawing tools
  isDrawing = true;
  startX = x; startY = y;
  lastX = x; lastY = y;

  if (currentTool === 'pencil' || currentTool === 'eraser') {
    saveState();
    const color = currentTool === 'eraser' ? bgColor : drawColor(e.button);
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  if (currentTool === 'line' || currentTool === 'rect' || currentTool === 'ellipse') {
    saveState();
  }
}

function onDocMouseMove(e) {
  const {x, y} = getCoords(e);
  updatePosStatus(clamp(x, 0, canvas.width - 1), clamp(y, 0, canvas.height - 1));

  // Resize handles
  if (resizing) {
    const dx = (e.clientX - resizeStart.mx) / zoom;
    const dy = (e.clientY - resizeStart.my) / zoom;
    let nw = resizeStart.cw, nh = resizeStart.ch;
    if (resizing === 'se' || resizing === 'e') nw = Math.max(1, Math.round(resizeStart.cw + dx));
    if (resizing === 'se' || resizing === 's') nh = Math.max(1, Math.round(resizeStart.ch + dy));
    resizeCanvas(nw, nh);
    return;
  }

  if (!isDrawing) {
    // Update cursor for selection move
    if (currentTool === 'select' && sel && insideSelection(x, y)) {
      canvas.style.cursor = 'move';
    } else if (currentTool === 'select') {
      canvas.style.cursor = 'crosshair';
    }
    return;
  }

  if (currentTool === 'pencil' || currentTool === 'eraser') {
    const color = currentTool === 'eraser' ? bgColor : drawColor(drawButton);
    drawLineOnCtx(ctx, lastX, lastY, x, y, color, brushSize);
    lastX = x; lastY = y;
    return;
  }

  if (currentTool === 'select') {
    if (selDragStart) {
      // Moving selection
      if (!selDragStart.lifted) {
        saveState();
        liftSelection(selDragStart.ctrl);
        selDragStart.lifted = true;
      }
      sel.x = selDragStart.selX + (x - selDragStart.x);
      sel.y = selDragStart.selY + (y - selDragStart.y);
      drawMarchingAnts();
    } else {
      // Drawing new selection
      const lx = Math.min(startX, x), ly = Math.min(startY, y);
      const w = Math.abs(x - startX), h = Math.abs(y - startY);
      if (shiftHeld) {
        const s = Math.max(w, h);
        sel.x = x < startX ? startX - s : startX;
        sel.y = y < startY ? startY - s : startY;
        sel.w = s; sel.h = s;
      } else {
        sel.x = lx; sel.y = ly; sel.w = w; sel.h = h;
      }
      drawMarchingAnts();
    }
    return;
  }

  // Text box preview on overlay
  if (currentTool === 'text') {
    clearOverlay();
    const lx = Math.min(startX, x), ly = Math.min(startY, y);
    const w = Math.abs(x - startX), h = Math.abs(y - startY);
    octx.save();
    octx.setLineDash([4, 4]);
    octx.strokeStyle = fgColor;
    octx.lineWidth = 1;
    octx.strokeRect(lx + 0.5, ly + 0.5, w, h);
    octx.restore();
    return;
  }

  // Shape/line preview on overlay
  if (currentTool === 'line' || currentTool === 'rect' || currentTool === 'ellipse') {
    clearOverlay();
    const color = drawColor(drawButton);
    const fillCol = drawButton === 2 ? fgColor : bgColor;
    drawShapePreview(octx, currentTool, startX, startY, x, y, color, fillCol, brushSize, shiftHeld);
  }
}

function onDocMouseUp(e) {
  if (resizing) {
    resizing = null;
    resizeStart = null;
    return;
  }
  if (!isDrawing) return;
  isDrawing = false;
  const {x, y} = getCoords(e);

  if (currentTool === 'select') {
    if (selDragStart) {
      selDragStart = null;
    } else {
      // Finalize selection rect
      if (sel && sel.w < 2 && sel.h < 2) {
        sel = null;
        stopMarch();
      }
    }
    return;
  }

  if (currentTool === 'text') {
    clearOverlay();
    const lx = Math.min(startX, x), ly = Math.min(startY, y);
    let w = Math.abs(x - startX), h = Math.abs(y - startY);
    if (w < 20 && h < 20) { w = 200; h = 80; }
    showTextInput(lx, ly, w, h);
    return;
  }

  if (currentTool === 'line' || currentTool === 'rect' || currentTool === 'ellipse') {
    clearOverlay();
    const color = drawColor(drawButton);
    const fillCol = drawButton === 2 ? fgColor : bgColor;
    drawShapePreview(ctx, currentTool, startX, startY, x, y, color, fillCol, brushSize, shiftHeld);
  }
}

// ============================================================
// RESIZE HANDLES
// ============================================================
['resize-se', 'resize-s', 'resize-e'].forEach(id => {
  const el = document.getElementById(id);
  el.addEventListener('mousedown', e => {
    e.preventDefault();
    e.stopPropagation();
    saveState();
    resizing = id.replace('resize-', '');
    resizeStart = {mx: e.clientX, my: e.clientY, cw: canvas.width, ch: canvas.height};
  });
});

// ============================================================
// ZOOM (Ctrl + scroll)
// ============================================================
workspace.addEventListener('wheel', e => {
  if (e.ctrlKey || e.metaKey) {
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.05 : 0.05;
    setZoom(Math.round((zoom + delta) * 100) / 100);
  }
}, {passive: false});

// ============================================================
// KEYBOARD SHORTCUTS
// ============================================================
document.addEventListener('keydown', e => {
  const ctrl = e.ctrlKey || e.metaKey;

  // Don't intercept if typing in the text box - let browser handle Ctrl+A/C/X/V/Z/Y natively
  const _ae = document.activeElement;
  const _inTextBox = _ae === textContent || textContent.contains(_ae);
  const _inInput = _inTextBox || _ae?.tagName === 'INPUT';
  if (_inInput && !ctrl) return;
  if (_inTextBox && ctrl && 'acxvzy'.includes(e.key)) return;

  if (ctrl && e.key === 'z') { e.preventDefault(); undo(); }
  if (ctrl && e.key === 'y') { e.preventDefault(); redo(); }
  if (ctrl && e.key === 'c') { e.preventDefault(); copySelection(); }
  if (ctrl && e.key === 'x') { e.preventDefault(); cutSelection(); }
  if (ctrl && e.key === 'a') { e.preventDefault(); selectAll(); setTool('select'); }
  if (ctrl && e.key === 'n') { e.preventDefault(); newCanvas(); }
  if (ctrl && e.key === 'o') { e.preventDefault(); document.getElementById('fileInput').click(); }
  if (ctrl && e.key === 'v') { e.preventDefault(); /* paste event handles system clipboard */ if (clipboard) pasteClipboard(); }
  if (ctrl && e.key === 's') { e.preventDefault(); saveFile('png'); }
  if (ctrl && e.key === '=') { e.preventDefault(); setZoom(Math.round((zoom + 0.05) * 100) / 100); }
  if (ctrl && e.key === '-') { e.preventDefault(); setZoom(Math.round((zoom - 0.05) * 100) / 100); }
  if (ctrl && e.key === '0') { e.preventDefault(); setZoom(1); }
  if (e.key === 'Escape') {
    if (textActive) commitText();
    else if (sel) { commitSelection(); }
  }
  if (e.key === 'Delete') {
    if (sel) { saveState(); if (sel.floating) { sel = null; stopMarch(); } else { ctx.fillStyle = bgColor; ctx.fillRect(sel.x, sel.y, sel.w, sel.h); sel = null; stopMarch(); } }
    else if (!ctrl) { saveState(); ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvas.width, canvas.height); }
  }

  // Tool shortcuts (only when not typing in inputs)
  const ae = document.activeElement;
  const inInput = ae === textContent || ae?.tagName === 'INPUT';
  if (!ctrl && !inInput) {
    const map = {s: 'select', p: 'pencil', e: 'eraser', f: 'fill', l: 'line', r: 'rect', o: 'ellipse', t: 'text', i: 'picker'};
    if (map[e.key]) setTool(map[e.key]);
    if (e.key === 'x' || e.key === 'X') { [fgColor, bgColor] = [bgColor, fgColor]; updateColorDisplay(); }
  }
});

// Paste from clipboard
document.addEventListener('paste', e => {
  const items = e.clipboardData?.items;
  if (!items) return;
  for (const item of items) {
    if (item.type.startsWith('image/')) {
      e.preventDefault();
      const blob = item.getAsFile();
      const img = new Image();
      img.onload = () => {
        const tmp = document.createElement('canvas');
        tmp.width = img.width; tmp.height = img.height;
        tmp.getContext('2d').drawImage(img, 0, 0);
        const data = tmp.getContext('2d').getImageData(0, 0, img.width, img.height);
        pasteWithSizeCheck(data);
      };
      img.src = URL.createObjectURL(blob);
      return;
    }
  }
  // Internal paste
  if (clipboard) { e.preventDefault(); pasteClipboard(); }
});

// ============================================================
// FILE OPERATIONS
// ============================================================
function newCanvas() {
  saveState();
  canvas.width = 800;
  canvas.height = 600;
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, 800, 600);
  sel = null;
  stopMarch();
  syncOverlay();
  updateSizeStatus();
}

function openFile(file) {
  const img = new Image();
  img.onload = () => {
    saveState();
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    sel = null;
    stopMarch();
    syncOverlay();
    updateSizeStatus();
  };
  img.src = URL.createObjectURL(file);
}

function saveFile(format) {
  commitSelection();
  commitText();
  const mime = format === 'jpg' ? 'image/jpeg' : format === 'webp' ? 'image/webp' : 'image/png';
  const ext = format === 'jpg' ? 'jpg' : format === 'webp' ? 'webp' : 'png';
  canvas.toBlob(blob => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'image.' + ext;
    a.click();
    URL.revokeObjectURL(a.href);
  }, mime, 0.92);
}

function insertImage(file) {
  const img = new Image();
  img.onload = () => {
    const tmp = document.createElement('canvas');
    tmp.width = img.width; tmp.height = img.height;
    tmp.getContext('2d').drawImage(img, 0, 0);
    const data = tmp.getContext('2d').getImageData(0, 0, img.width, img.height);
    pasteWithSizeCheck(data);
  };
  img.src = URL.createObjectURL(file);
}

document.getElementById('fileInput').addEventListener('change', e => {
  if (e.target.files[0]) openFile(e.target.files[0]);
  e.target.value = '';
});

// ============================================================
// DRAG & DROP
// ============================================================
const dropzone = document.getElementById('dropzone');

workspace.addEventListener('dragover', e => {
  e.preventDefault();
  dropzone.style.display = 'flex';
});
workspace.addEventListener('dragleave', e => {
  if (!workspace.contains(e.relatedTarget)) dropzone.style.display = 'none';
});
workspace.addEventListener('drop', e => {
  e.preventDefault();
  dropzone.style.display = 'none';
  const files = e.dataTransfer.files;
  if (files.length && files[0].type.startsWith('image/')) {
    insertImage(files[0]);
  }
});

// ============================================================
// IMAGE TRANSFORMS
// ============================================================
function flipCanvas(horizontal) {
  saveState();
  const tmp = document.createElement('canvas');
  tmp.width = canvas.width; tmp.height = canvas.height;
  const tc = tmp.getContext('2d');
  if (horizontal) { tc.translate(canvas.width, 0); tc.scale(-1, 1); }
  else { tc.translate(0, canvas.height); tc.scale(1, -1); }
  tc.drawImage(canvas, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(tmp, 0, 0);
}

function rotateCanvas(cw) {
  saveState();
  const tmp = document.createElement('canvas');
  tmp.width = canvas.height; tmp.height = canvas.width;
  const tc = tmp.getContext('2d');
  if (cw) { tc.translate(tmp.width, 0); tc.rotate(Math.PI / 2); }
  else { tc.translate(0, tmp.height); tc.rotate(-Math.PI / 2); }
  tc.drawImage(canvas, 0, 0);
  canvas.width = tmp.width;
  canvas.height = tmp.height;
  ctx.drawImage(tmp, 0, 0);
  syncOverlay();
  updateSizeStatus();
}

// ============================================================
// MENU SYSTEM
// ============================================================
document.querySelectorAll('.menu-item').forEach(item => {
  item.addEventListener('click', e => {
    if (e.target.closest('.menu-dropdown')) return;
    document.querySelectorAll('.menu-item').forEach(m => {
      if (m !== item) m.classList.remove('open');
    });
    item.classList.toggle('open');
  });
});

document.addEventListener('click', e => {
  if (!e.target.closest('.menu-item')) {
    document.querySelectorAll('.menu-item').forEach(m => m.classList.remove('open'));
  }
});

document.querySelectorAll('.menu-dropdown div[data-action]').forEach(el => {
  el.addEventListener('click', e => {
    const action = el.dataset.action;
    document.querySelectorAll('.menu-item').forEach(m => m.classList.remove('open'));

    switch(action) {
      case 'new': newCanvas(); break;
      case 'open': document.getElementById('fileInput').click(); break;
      case 'save-png': saveFile('png'); break;
      case 'save-jpg': saveFile('jpg'); break;
      case 'save-webp': saveFile('webp'); break;
      case 'undo': undo(); break;
      case 'redo': redo(); break;
      case 'cut': cutSelection(); break;
      case 'copy': copySelection(); break;
      case 'paste': if(clipboard) pasteClipboard(); break;
      case 'select-all': selectAll(); setTool('select'); break;
      case 'deselect': commitSelection(); break;
      case 'crop': cropToSelection(); break;
      case 'zoom-in': setZoom(Math.round((zoom + 0.05) * 100) / 100); break;
      case 'zoom-out': setZoom(Math.round((zoom - 0.05) * 100) / 100); break;
      case 'zoom-reset': setZoom(1); break;
      case 'flip-h': flipCanvas(true); break;
      case 'flip-v': flipCanvas(false); break;
      case 'rotate-cw': rotateCanvas(true); break;
      case 'rotate-ccw': rotateCanvas(false); break;
      case 'clear-canvas': saveState(); ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvas.width, canvas.height); break;
    }
  });
});

// ============================================================
// TOOLBAR EVENTS
// ============================================================
document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
  btn.addEventListener('click', () => setTool(btn.dataset.tool));
});

function syncBrushUI() {
  document.getElementById('brushSize').value = brushSize;
  document.getElementById('brushSizeVal').value = brushSize;
}

document.getElementById('brushSize').addEventListener('input', e => {
  brushSize = parseInt(e.target.value);
  document.getElementById('brushSizeVal').value = brushSize;
});

document.getElementById('brushSizeVal').addEventListener('change', e => {
  brushSize = clamp(parseInt(e.target.value) || 1, 1, 100);
  syncBrushUI();
});
document.getElementById('brushSizeVal').addEventListener('keydown', e => {
  if (e.key === 'Enter') e.target.blur();
});

function updateBrushSize(delta) {
  brushSize = clamp(brushSize + delta, 1, 100);
  syncBrushUI();
}
setupRepeatButton('brushMinus', () => updateBrushSize(-1), null, 200);
setupRepeatButton('brushPlus', () => updateBrushSize(1), null, 200);

// Font size +/- buttons
function updateFontSize(delta) {
  const inp = document.getElementById('fontSizeInput');
  inp.value = clamp(parseInt(inp.value) + delta, 8, 200);
  inp.dispatchEvent(new Event('input'));
}
setupRepeatButton('fontMinus', () => updateFontSize(-1), null, 200);
setupRepeatButton('fontPlus', () => updateFontSize(1), null, 200);
document.getElementById('fontSizeInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') e.target.blur();
});

document.getElementById('brushSize').addEventListener('wheel', e => {
  e.preventDefault();
  updateBrushSize(e.deltaY > 0 ? -1 : 1);
}, {passive: false});

// Select mode dropdown
const selectDropArrow = document.getElementById('selectDropArrow');
const selectDropMenu = document.getElementById('selectDropMenu');

selectDropArrow.addEventListener('click', e => {
  e.stopPropagation();
  rectDropMenu.classList.remove('open');
  selectDropMenu.classList.toggle('open');
});

// Rectangle mode dropdown
const rectDropArrow = document.getElementById('rectDropArrow');
const rectDropMenu = document.getElementById('rectDropMenu');

rectDropArrow.addEventListener('click', e => {
  e.stopPropagation();
  selectDropMenu.classList.remove('open');
  rectDropMenu.classList.toggle('open');
});

// Close all tool dropdowns on outside click
document.addEventListener('click', e => {
  if (!e.target.closest('#selectDropArrow')) selectDropMenu.classList.remove('open');
  if (!e.target.closest('#rectDropArrow')) rectDropMenu.classList.remove('open');
});

document.querySelectorAll('#selectDropMenu div[data-selmode]').forEach(el => {
  el.addEventListener('click', () => {
    selectMode = el.dataset.selmode;
    document.querySelectorAll('#selectDropMenu div').forEach(d => d.classList.toggle('dm-active', d === el));
    selectDropMenu.classList.remove('open');
    const icon = document.getElementById('selectIcon');
    if (selectMode === 'ellipse') {
      icon.innerHTML = '<ellipse cx="9" cy="9" rx="7" ry="6" fill="none" stroke="currentColor" stroke-width="1.5" stroke-dasharray="3 2"/>';
    } else {
      icon.innerHTML = '<rect x="2" y="2" width="14" height="14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-dasharray="3 2"/>';
    }
    setTool('select');
  });
});

document.querySelectorAll('#rectDropMenu div[data-rectmode]').forEach(el => {
  el.addEventListener('click', () => {
    rectMode = el.dataset.rectmode;
    document.querySelectorAll('#rectDropMenu div').forEach(d => d.classList.toggle('dm-active', d === el));
    rectDropMenu.classList.remove('open');
    const icon = document.getElementById('rectIcon');
    if (rectMode === 'rounded') {
      icon.innerHTML = '<rect x="2" y="4" width="14" height="10" rx="3" fill="none" stroke="currentColor" stroke-width="1.5"/>';
    } else {
      icon.innerHTML = '<rect x="2" y="4" width="14" height="10" fill="none" stroke="currentColor" stroke-width="1.5"/>';
    }
    setTool('rect');
  });
});

document.querySelectorAll('.shape-btn[data-shapestyle]').forEach(btn => {
  btn.addEventListener('click', () => {
    shapeStyle = btn.dataset.shapestyle;
    document.querySelectorAll('.shape-btn').forEach(b => b.classList.toggle('active', b === btn));
  });
});

// ============================================================
// ZOOM CONTROLS (+/- buttons with long-press repeat)
// ============================================================
function setupRepeatButton(btnId, action, btnEl, repeatMs) {
  const btn = btnEl || document.getElementById(btnId);
  const ms = repeatMs || 500;
  let timer = null, interval = null;
  function start(e) {
    e.preventDefault();
    action();
    timer = setTimeout(() => {
      interval = setInterval(action, ms);
    }, 400);
  }
  function stop() {
    clearTimeout(timer); clearInterval(interval);
    timer = null; interval = null;
  }
  btn.addEventListener('mousedown', start);
  btn.addEventListener('mouseup', stop);
  btn.addEventListener('mouseleave', stop);
}

setupRepeatButton('zoomPlus', () => setZoom(Math.round((zoom + 0.05) * 100) / 100));
setupRepeatButton('zoomMinus', () => setZoom(Math.round((zoom - 0.05) * 100) / 100));

// ============================================================
// COLOR PALETTE
// ============================================================
const PALETTE_COLORS = [
  '#000000','#7f7f7f','#880015','#ed1c24','#ff7f27','#fff200','#22b14c','#00a2e8','#3f48cc','#a349a4',
  '#ffffff','#c3c3c3','#b97a57','#ffaec9','#ffc90e','#efe4b0','#b5e61d','#99d9ea','#7092be','#c8bfe7',
  '#404040','#585858','#c04000','#f06060','#f0a050','#e0d040','#10802a','#2070a0','#2830a0','#803080',
  '#202020','#a0a0a0','#602000','#a01010','#c06000','#a09000','#006818','#005080','#1a1870','#501860',
];

const palette = document.getElementById('palette');
PALETTE_COLORS.forEach(c => {
  const cell = document.createElement('div');
  cell.className = 'color-cell';
  cell.style.background = c;
  cell.addEventListener('mousedown', e => e.preventDefault()); // keep text selection alive
  cell.addEventListener('click', () => setFgColor(c));
  cell.addEventListener('contextmenu', e => { e.preventDefault(); bgColor = c; updateColorDisplay(); });
  palette.appendChild(cell);
});

// Custom color button
const customBtn = document.createElement('div');
customBtn.id = 'custom-color-btn';
customBtn.title = 'Custom color';
customBtn.addEventListener('mousedown', e => e.preventDefault());
customBtn.addEventListener('click', () => {
  const cp = document.getElementById('colorPicker');
  cp.value = fgColor;
  cp._target = 'fg';
  cp.click();
});
customBtn.addEventListener('contextmenu', e => {
  e.preventDefault();
  const cp = document.getElementById('colorPicker');
  cp.value = bgColor;
  cp._target = 'bg';
  cp.click();
});
palette.appendChild(customBtn);

document.getElementById('colorPicker').addEventListener('input', e => {
  if (e.target._target === 'bg') { bgColor = e.target.value; updateColorDisplay(); }
  else setFgColor(e.target.value);
});

function updateColorDisplay() {
  document.getElementById('fg-color-box').style.background = fgColor;
  document.getElementById('bg-color-box').style.background = bgColor;
}

function setFgColor(c) {
  fgColor = c;
  updateColorDisplay();
  if (textActive) {
    const sel = window.getSelection();
    if (sel.rangeCount && !sel.isCollapsed && textContent.contains(sel.anchorNode)) {
      document.execCommand('foreColor', false, c);
    }
    textContent.style.color = fgColor; // default for new text
  }
}

document.getElementById('fg-color-box').addEventListener('click', () => {
  const cp = document.getElementById('colorPicker');
  cp.value = fgColor; cp._target = 'fg'; cp.click();
});
document.getElementById('bg-color-box').addEventListener('click', () => {
  const cp = document.getElementById('colorPicker');
  cp.value = bgColor; cp._target = 'bg'; cp.click();
});
document.getElementById('swap-colors').addEventListener('click', () => {
  [fgColor, bgColor] = [bgColor, fgColor];
  updateColorDisplay();
});

// ============================================================
// INIT
// ============================================================
// Text content blur handler - don't auto-commit, let user use checkmark/Esc/tool switch
textContent.addEventListener('blur', e => {
  setTimeout(() => {
    if (textActive && !textWrapper.contains(document.activeElement) && !e.relatedTarget?.closest('#fontGroup')) {
      // Only commit if focus went somewhere other than the text wrapper or font controls
    }
  }, 200);
});

// ============================================================
// CONFIRM DIALOG
// ============================================================
function showConfirm(msg) {
  return new Promise(resolve => {
    const dlg = document.getElementById('confirm-dialog');
    document.getElementById('confirm-msg').textContent = msg;
    dlg.classList.add('open');
    function cleanup(val) {
      dlg.classList.remove('open');
      document.getElementById('confirm-yes').removeEventListener('click', onYes);
      document.getElementById('confirm-no').removeEventListener('click', onNo);
      resolve(val);
    }
    function onYes() { cleanup(true); }
    function onNo() { cleanup(false); }
    document.getElementById('confirm-yes').addEventListener('click', onYes);
    document.getElementById('confirm-no').addEventListener('click', onNo);
  });
}

// ============================================================
// CANVAS SIZE INPUTS
// ============================================================
function commitSizeInput() {
  const w = clamp(parseInt(document.getElementById('sizeW').value) || canvas.width, 1, 9999);
  const h = clamp(parseInt(document.getElementById('sizeH').value) || canvas.height, 1, 9999);
  if (w !== canvas.width || h !== canvas.height) {
    saveState();
    resizeCanvas(w, h);
  }
  // Sync back in case clamped
  updateSizeStatus();
}

document.getElementById('sizeW').addEventListener('change', commitSizeInput);
document.getElementById('sizeH').addEventListener('change', commitSizeInput);
document.getElementById('sizeW').addEventListener('keydown', e => { if (e.key === 'Enter') { e.target.blur(); } });
document.getElementById('sizeH').addEventListener('keydown', e => { if (e.key === 'Enter') { e.target.blur(); } });

// Dimension +/- buttons with long-press repeat
document.querySelectorAll('.dim-btn').forEach(btn => {
  const dim = btn.dataset.dim;
  const delta = parseInt(btn.dataset.delta);
  const input = dim === 'w' ? document.getElementById('sizeW') : document.getElementById('sizeH');
  function step() {
    const cur = parseInt(input.value) || 1;
    input.value = clamp(cur + delta, 1, 9999);
    commitSizeInput();
  }
  setupRepeatButton(null, step, btn, 50);
});


// ============================================================
// IMAGE INSERT WITH RESIZE PROMPT
// ============================================================
async function pasteWithSizeCheck(data) {
  if (data.width > canvas.width || data.height > canvas.height) {
    const newW = Math.max(canvas.width, data.width);
    const newH = Math.max(canvas.height, data.height);
    const yes = await showConfirm(
      'The image (' + data.width + '\u00d7' + data.height +
      ') is larger than the canvas (' + canvas.width + '\u00d7' + canvas.height +
      '). Resize canvas to ' + newW + '\u00d7' + newH + '?'
    );
    if (yes) {
      saveState();
      resizeCanvas(newW, newH);
    }
  }
  pasteClipboard(data);
}

// ============================================================
// HELP PANEL
// ============================================================
const helpOverlay = document.getElementById('help-overlay');
document.getElementById('help-btn').addEventListener('click', () => helpOverlay.classList.add('open'));
document.getElementById('help-close').addEventListener('click', () => helpOverlay.classList.remove('open'));
helpOverlay.addEventListener('click', e => { if (e.target === helpOverlay) helpOverlay.classList.remove('open'); });
document.addEventListener('keydown', e => {
  if (e.key === '?' && !document.activeElement.matches('input,[contenteditable]')) helpOverlay.classList.toggle('open');
  if (e.key === 'Escape' && helpOverlay.classList.contains('open')) { helpOverlay.classList.remove('open'); e.stopPropagation(); }
}, true);

// ============================================================
// DARK MODE
// ============================================================
const darkToggle = document.getElementById('darkToggle');
function applyDarkMode(on) {
  document.body.classList.toggle('dark', on);
  darkToggle.checked = on;
  document.getElementById('dmLabel').textContent = on ? 'Dark' : 'Dark';
  try { localStorage.setItem('paint-dark', on ? '1' : '0'); } catch(e) {}
}
darkToggle.addEventListener('change', () => applyDarkMode(darkToggle.checked));
// Restore preference
try { if (localStorage.getItem('paint-dark') === '1') applyDarkMode(true); } catch(e) {}

// ============================================================
// INIT
// ============================================================
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, canvas.width, canvas.height);
syncOverlay();
updateColorDisplay();
updateSizeStatus();
setTool('pencil');

// Prevent default browser zoom on Ctrl+scroll for the whole page
document.addEventListener('wheel', e => {
  if (e.ctrlKey) e.preventDefault();
}, {passive: false});
</script>
</body>
</html>
